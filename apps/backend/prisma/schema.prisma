generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id                            String   @id @default(uuid())
  // Legacy: Twitch channel id. Optional to support non-Twitch streamers in the future.
  twitchChannelId               String?  @unique
  slug                          String   @unique
  name                          String
  rewardIdForCoins              String?
  coinPerPointRatio             Float    @default(1.0)
  rewardEnabled                 Boolean  @default(false) // Is reward enabled/active
  rewardTitle                   String? // Title of the reward in Twitch
  rewardCost                    Int? // Cost in channel points
  rewardCoins                   Int? // Coins granted per redemption
  // If true, coins for the Twitch channel points reward are granted only when stream is online.
  rewardOnlyWhenLive            Boolean  @default(false)
  coinIconUrl                   String? // Custom coin icon URL from Twitch reward
  primaryColor                  String? // Hex color for primary theme
  secondaryColor                String? // Hex color for secondary theme
  accentColor                   String? // Hex color for accent
  defaultPriceCoins             Int?     @default(100) // Default price for memes in this channel
  submissionRewardCoins         Int      @default(0) // Coins granted to submitter when their submission is approved
  // If true, submission approval coins are granted only when stream is online.
  submissionRewardOnlyWhenLive  Boolean  @default(false)
  // OBS overlay settings (server-side defaults for tokenized overlay URLs)
  overlayMode                   String   @default("queue") // queue | simultaneous
  overlayShowSender             Boolean  @default(false)
  overlayMaxConcurrent          Int      @default(3)
  // Advanced OBS overlay appearance/animation settings (stored as JSON string)
  overlayStyleJson              String?  @db.Text
  // OBS overlay presets (per-channel, stored as JSON string; validated/size-limited by API)
  overlayPresetsJson            String?  @db.Text
  // Increment to invalidate previously issued overlay tokens.
  overlayTokenVersion           Int      @default(1)
  // OBS credits overlay (titres) settings (stored as JSON string)
  creditsStyleJson              String?  @db.Text
  // Increment to invalidate previously issued credits tokens.
  creditsTokenVersion           Int      @default(1)
  // Credits session reconnect window in minutes (keep session alive after stream goes offline / bot disconnects).
  creditsReconnectWindowMinutes Int      @default(60)
  // Chat bot "smart" command: stream duration settings (stored as JSON string; validated by API).
  streamDurationCommandJson     String?  @db.Text
  // Chat bot follow greeting settings
  followGreetingsEnabled        Boolean  @default(false)
  followGreetingTemplate        String?  @db.Text
  createdAt                     DateTime @default(now())

  users                 User[]
  wallets               Wallet[]
  memes                 Meme[]
  submissions           MemeSubmission[]
  redemptions           Redemption[]
  activations           MemeActivation[]
  auditLogs             AuditLog[]
  promotions            Promotion[]
  dailyStats            ChannelDailyStats[]
  userStats30d          ChannelUserStats30d[]
  memeStats30d          ChannelMemeStats30d[]
  memeDailyStats        ChannelMemeDailyStats[]
  chatBotSubscriptions  ChatBotSubscription[]
  chatBotOutboxMessages ChatBotOutboxMessage[]
  chatBotCommands       ChatBotCommand[]
  chatBotEventDedups    ChatBotEventDedup[]
  vkVideoChatBotSubscriptions  VkVideoChatBotSubscription[]
  vkVideoChatBotOutboxMessages VkVideoChatBotOutboxMessage[]
  botIntegrations       BotIntegrationSettings[]
  youTubeChatBotSubscriptions  YouTubeChatBotSubscription[]
  youTubeChatBotOutboxMessages YouTubeChatBotOutboxMessage[]
  youTubeBotIntegration        YouTubeBotIntegration?
}

enum BotIntegrationProvider {
  twitch
  vkplaylive
  vkvideo
  youtube
}

// Per-channel bot integration toggles (survive restarts/deploys).
// - twitch: gates ChatBotSubscription (Twitch IRC bot joins/parts)
// - vkplaylive: reserved for VKPlay Live chat integration (uses ENV mapping for now)
model BotIntegrationSettings {
  id        String                 @id @default(uuid())
  channelId String
  provider  BotIntegrationProvider
  enabled   Boolean                @default(false)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, provider])
  @@index([channelId])
  @@index([provider, enabled])
  @@index([enabled])
}

enum ExternalAccountProvider {
  twitch
  youtube
  vk
  vkvideo
  vkplay
  kick
  trovo
  boosty
}

// VK Video Live chat bot subscriptions (global bot account joins many channels).
// Each MemAlerts Channel maps to a single VK Video Live channel identifier used by the chat connection.
model VkVideoChatBotSubscription {
  id              String   @id @default(uuid())
  channelId        String
  // Channel owner (used to access VKVideo API for roles; optional for backward compatibility).
  userId           String?
  vkvideoChannelId String // platform channel identifier (exact format depends on VKVideo chat API)
  // Full channel URL on VK Video Live (required to resolve stream_id and websocket channel names via DevAPI).
  vkvideoChannelUrl String?
  enabled          Boolean  @default(true)
  createdAt        DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([channelId])
  @@index([enabled])
  @@index([vkvideoChannelId])
  @@index([vkvideoChannelUrl])
  @@index([channelId])
  @@index([userId])
}

// VK Video Live chat bot outbox for sending messages via the separate vkvideo chatbot runner process.
model VkVideoChatBotOutboxMessage {
  id              String @id @default(uuid())
  channelId        String
  vkvideoChannelId String
  message         String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([vkvideoChannelId, status, createdAt])
  @@index([createdAt])
}

enum OAuthStateKind {
  login
  link
  bot_link
}

// Global Twitch IRC bot subscriptions (single bot account joins many channels).
model ChatBotSubscription {
  id          String   @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (for JOIN #login)
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([twitchLogin])
  @@index([channelId])
}

// YouTube chat bot subscriptions (per-channel, uses the streamer's linked YouTube account).
// Each MemAlerts Channel maps to a single YouTube channelId (owner's channel).
model YouTubeChatBotSubscription {
  id              String   @id @default(uuid())
  channelId        String
  userId           String
  youtubeChannelId String
  enabled          Boolean  @default(true)
  createdAt        DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([youtubeChannelId])
  @@index([userId])
  @@index([channelId])
}

// YouTube chat bot outbox for sending messages via the separate youtubeChatbotRunner process.
// API enqueues messages here; runner polls, delivers to YouTube Live Chat, then marks sent/failed.
model YouTubeChatBotOutboxMessage {
  id              String @id @default(uuid())
  channelId        String
  youtubeChannelId String
  message         String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([youtubeChannelId, status, createdAt])
  @@index([createdAt])
}

// Chat bot outbox for sending messages via the separate chatbotRunner process.
// API enqueues messages here; runner polls, delivers to Twitch IRC, then marks sent/failed.
model ChatBotOutboxMessage {
  id          String @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (target channel)
  message     String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([twitchLogin, status, createdAt])
  @@index([createdAt])
}

// Per-channel chat bot commands (trigger -> response).
model ChatBotCommand {
  id                String   @id @default(uuid())
  channelId         String
  trigger           String
  triggerNormalized String
  response          String   @db.Text
  enabled           Boolean  @default(true)
  // If true, bot replies only when stream is online.
  onlyWhenLive      Boolean  @default(false)
  // Command audience:
  // - if both arrays are empty => everyone can trigger the command
  // - if allowedUsers contains sender login => allowed
  // - else if allowedRoles contains sender role => allowed
  // NOTE: "follower" role is currently not resolvable from IRC tags; see chatbotRunner.ts.
  allowedRoles      Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  allowedUsers      Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  // VKVideo-specific role ids (from VKVideo Channel Roles API).
  // Stored separately because Twitch allowedRoles are a fixed enum.
  vkvideoAllowedRoleIds Json  @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, triggerNormalized])
  @@index([channelId])
  @@index([enabled])
  @@index([channelId, enabled])
  @@index([triggerNormalized])
}

// Dedupe table for chat-bot-triggering events (e.g., EventSub follow) to prevent duplicate greetings.
model ChatBotEventDedup {
  id        String   @id @default(uuid())
  channelId String
  kind      String // e.g. "follow"
  eventId   String
  createdAt DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([kind, eventId])
  @@index([channelId])
  @@index([kind])
  @@index([createdAt])
}

// Per-user cross-device UI preferences.
// NOTE: kept additive and isolated to a single row per user (no channel dimension).
model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  theme                String   @default("light") // light | dark
  autoplayMemesEnabled Boolean  @default(true)
  memeModalMuted       Boolean  @default(false)
  coinsInfoSeen        Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id                 String   @id @default(uuid())
  // Legacy: Twitch user id. Optional to support non-Twitch identities in the future.
  twitchUserId       String?  @unique
  displayName        String
  profileImageUrl    String? // Twitch profile image URL
  role               String // viewer, streamer, admin
  channelId          String?
  twitchAccessToken  String? // Twitch OAuth access token for API calls
  twitchRefreshToken String? // Twitch OAuth refresh token
  hasBetaAccess      Boolean  @default(false) // Beta access flag
  createdAt          DateTime @default(now())

  channel          Channel?              @relation(fields: [channelId], references: [id], onDelete: SetNull)
  preference       UserPreference?
  externalAccounts ExternalAccount[]
  oauthStates      OAuthState[]
  youTubeChatBotSubscriptions YouTubeChatBotSubscription[]
  vkVideoChatBotSubscriptions VkVideoChatBotSubscription[]
  wallets          Wallet[]
  memesCreated     Meme[]                @relation("CreatedBy")
  memesApproved    Meme[]                @relation("ApprovedBy")
  submissions      MemeSubmission[]
  redemptions      Redemption[]
  activations      MemeActivation[]
  channelStats30d  ChannelUserStats30d[]
  auditLogs        AuditLog[]
  betaAccess       BetaAccess?

  @@index([twitchUserId])
  @@index([channelId])
  @@index([hasBetaAccess])
}

model ExternalAccount {
  id                String                  @id @default(uuid())
  userId            String
  provider          ExternalAccountProvider
  providerAccountId String

  // Profile-ish fields (best-effort, provider-dependent)
  displayName String?
  login       String?
  avatarUrl   String?
  profileUrl  String?

  // OAuth tokens (optional; some providers may not return refresh tokens etc.)
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?
  scopes         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  youTubeBotIntegration YouTubeBotIntegration?

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
  @@index([providerAccountId])
}

model OAuthState {
  // Random state string used as primary key (stored server-side for verification)
  state    String                  @id
  provider ExternalAccountProvider
  kind     OAuthStateKind

  // For link flows: the authenticated user that initiated linking.
  userId String?
  // For bot_link flows: channelId of the streamer who initiated linking.
  channelId String?

  // Redirect handling
  redirectTo String?
  origin     String?

  // PKCE-ready (not used for Twitch currently, but stored for future providers)
  codeVerifier String?

  expiresAt  DateTime
  consumedAt DateTime?

  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([provider, kind])
  @@index([userId])
  @@index([channelId])
}

// Optional per-channel YouTube "bot account" override.
// If present, YouTube chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global YouTube bot token (YOUTUBE_BOT_REFRESH_TOKEN).
model YouTubeBotIntegration {
  id                String   @id @default(uuid())
  channelId          String   @unique
  externalAccountId  String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel        @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String
  channelId String
  balance   Int      @default(0)
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
}

model Meme {
  id               String    @id @default(uuid())
  channelId        String
  title            String
  type             String // image, gif, video, audio
  fileUrl          String
  fileHash         String? // SHA-256 hash for deduplication
  durationMs       Int
  priceCoins       Int
  status           String // pending, approved, rejected
  deletedAt        DateTime?
  createdByUserId  String?
  approvedByUserId String?
  createdAt        DateTime  @default(now())

  channel           Channel                 @relation(fields: [channelId], references: [id], onDelete: Cascade)
  createdBy         User?                   @relation("CreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  approvedBy        User?                   @relation("ApprovedBy", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  activations       MemeActivation[]
  globalStats30d    GlobalMemeStats30d?
  globalDailyStats  GlobalMemeDailyStats[]
  tags              MemeTag[]
  channelStats30d   ChannelMemeStats30d[]
  channelDailyStats ChannelMemeDailyStats[]
  fileHashRef       FileHash?               @relation(fields: [fileHash], references: [hash], onDelete: SetNull)

  @@index([channelId])
  @@index([status])
  @@index([deletedAt])
  @@index([createdByUserId])
  @@index([fileHash])
  // Common read pattern: list approved memes for a channel ordered by createdAt
  @@index([channelId, status, createdAt])
}

model MemeSubmission {
  id              String   @id @default(uuid())
  channelId       String
  submitterUserId String
  title           String
  type            String // image, gif, video, audio
  fileUrlTemp     String
  sourceUrl       String? // URL of imported meme from memalerts.com
  notes           String?
  status          String // pending, approved, rejected
  moderatorNotes  String?
  // Number of times the submitter resubmitted this submission after "needs_changes".
  // Used to enforce a small iteration limit for scale (prevents infinite loops).
  revision        Int      @default(0)
  createdAt       DateTime @default(now())

  channel   Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  submitter User                @relation(fields: [submitterUserId], references: [id], onDelete: Cascade)
  tags      MemeSubmissionTag[]

  @@index([channelId])
  @@index([status])
  @@index([submitterUserId])
}

model Redemption {
  id                 String   @id @default(uuid())
  channelId          String
  userId             String
  twitchRedemptionId String   @unique
  pointsSpent        Int
  coinsGranted       Int
  status             String // pending, completed, failed
  createdAt          DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([twitchRedemptionId])
}

model MemeActivation {
  id         String   @id @default(uuid())
  channelId  String
  userId     String
  memeId     String
  coinsSpent Int
  status     String // queued, playing, done, failed
  createdAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([status])
  @@index([memeId])
  // Common time-range scans (e.g., daily charts / rollups)
  @@index([channelId, createdAt])
  // Admin stats groupBy helpers (group by userId/memeId within a channel)
  @@index([channelId, userId])
  @@index([channelId, memeId])
  // Query helpers:
  // - popularity ranking: filter by channelId + status + createdAt, group by memeId
  @@index([channelId, status, createdAt, memeId])
  // - favorites ranking: filter by channelId + userId + status, group by memeId
  @@index([channelId, userId, status, memeId])
}

model AuditLog {
  id          String   @id @default(uuid())
  actorId     String?
  channelId   String
  action      String
  payloadJson String   @db.Text
  createdAt   DateTime @default(now())

  actor   User?   @relation(fields: [actorId], references: [id], onDelete: SetNull)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([actorId])
  @@index([createdAt])
}

model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  memes       MemeTag[]
  submissions MemeSubmissionTag[]

  @@index([name])
}

model MemeTag {
  id     String @id @default(uuid())
  memeId String
  tagId  String

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([memeId, tagId])
  @@index([memeId])
  @@index([tagId])
}

model MemeSubmissionTag {
  id           String @id @default(uuid())
  submissionId String
  tagId        String

  submission MemeSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  tag        Tag            @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([submissionId, tagId])
  @@index([submissionId])
  @@index([tagId])
}

model Promotion {
  id              String   @id @default(uuid())
  channelId       String
  name            String
  discountPercent Float // 0-100, e.g., 50 for 50% discount
  startDate       DateTime
  endDate         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([isActive])
  @@index([startDate, endDate])
}

model FileHash {
  hash           String   @id // SHA-256 hash
  filePath       String // Path to physical file
  referenceCount Int      @default(1) // Number of references to this file
  fileSize       BigInt // File size in bytes
  mimeType       String // MIME type of the file
  createdAt      DateTime @default(now())

  memes Meme[]

  @@index([referenceCount])
}

model BetaAccess {
  id          String    @id @default(uuid())
  userId      String    @unique
  status      String // pending, approved, rejected
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  approvedBy  String? // User ID who approved/rejected
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

// Rollup / pre-aggregations for performance at scale.
// These tables are additive and safe for shared DB (beta+prod) when deployed with expand/contract strategy.
model ChannelDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC

  // All statuses (queued/playing/done/failed/etc). Mirrors admin daily chart semantics.
  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)

  // Completed-only (done/completed). Mirrors viewer stats semantics.
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  // Best-effort unique user counts (all statuses / completed).
  uniqueUsersCountAll       Int @default(0)
  uniqueUsersCountCompleted Int @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@id([channelId, day])
  @@index([channelId, day])
  @@index([day])
}

// 30-day rolling window rollups (min-load strategy):
// keep expensive groupBy queries off the hot path by precomputing aggregates on a fixed window.
model ChannelUserStats30d {
  channelId String
  userId    String

  // Window boundaries (UTC). Informational; recomputed by job.
  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId])
  @@index([channelId])
  @@index([channelId, totalCoinsSpentSum])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model ChannelMemeStats30d {
  channelId String
  memeId    String

  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, memeId])
  @@index([channelId])
  @@index([channelId, completedActivationsCount])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model GlobalMemeStats30d {
  memeId String

  windowStart DateTime
  windowEnd   DateTime

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([memeId])
  @@index([completedActivationsCount])
  @@index([updatedAt])
}

// Daily rollups for viewer stats (day/week/month aggregation without scanning MemeActivation).
model ChannelMemeDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC
  memeId    String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, day, memeId])
  @@index([channelId, day])
  @@index([channelId, memeId])
  @@index([day])
}

model GlobalMemeDailyStats {
  day    DateTime // date_trunc('day', createdAt) in UTC
  memeId String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([day, memeId])
  @@index([day])
  @@index([memeId])
}
