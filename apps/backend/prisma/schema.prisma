generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id                            String   @id @default(uuid())
  // Legacy: Twitch channel id. Optional to support non-Twitch streamers in the future.
  twitchChannelId               String?  @unique
  slug                          String   @unique
  name                          String
  rewardIdForCoins              String?
  coinPerPointRatio             Float    @default(1.0)
  rewardEnabled                 Boolean  @default(false) // Is reward enabled/active
  rewardTitle                   String? // Title of the reward in Twitch
  rewardCost                    Int? // Cost in channel points
  rewardCoins                   Int? // Coins granted per redemption
  // If true, coins for the Twitch channel points reward are granted only when stream is online.
  rewardOnlyWhenLive            Boolean  @default(false)
  // VKVideo channel points -> coins.
  vkvideoRewardEnabled          Boolean  @default(false)
  vkvideoRewardIdForCoins       String?
  vkvideoCoinPerPointRatio      Float    @default(1.0)
  vkvideoRewardCoins            Int?
  vkvideoRewardOnlyWhenLive     Boolean  @default(false)
  coinIconUrl                   String? // Custom coin icon URL from Twitch reward
  primaryColor                  String? // Hex color for primary theme
  secondaryColor                String? // Hex color for secondary theme
  accentColor                   String? // Hex color for accent
  defaultPriceCoins             Int?     @default(100) // Default price for memes in this channel
  // Which meme catalog is visible/usable on the channel page:
  // - "channel": only approved ChannelMeme items (current behavior)
  // - "pool_all": entire global pool (MemeAsset) becomes available for the channel
  memeCatalogMode               String   @default("channel")
  // Legacy: Coins granted to submitter when their submission is approved (kept for back-compat).
  submissionRewardCoins         Int      @default(0)
  // New: Separate rewards (upload/url vs pool import).
  submissionRewardCoinsUpload   Int      @default(0)
  submissionRewardCoinsPool     Int      @default(100)
  // Legacy: If true, submission approval coins are granted only when stream is online.
  // NOTE: For pool-import rollout we decided to ALWAYS reward (ignore this flag).
  submissionRewardOnlyWhenLive  Boolean  @default(false)
  // Viewer submissions gate (global per-channel).
  // - submissionsEnabled=false => viewers cannot create new submissions.
  // - submissionsOnlyWhenLive=true => viewers can submit only while stream is online (best-effort per stream status store).
  submissionsEnabled            Boolean  @default(true)
  submissionsOnlyWhenLive       Boolean  @default(false)
  // Strict auto-approve for viewer submissions (AI low-risk + content policy checks).
  autoApproveEnabled            Boolean  @default(false)
  // Public control token for StreamDeck/StreamerBot-like integrations.
  // Stored as SHA-256 hex hash (never store raw token).
  submissionsControlTokenHash   String?  @unique
  // OBS overlay settings (server-side defaults for tokenized overlay URLs)
  overlayMode                   String   @default("queue") // queue | simultaneous
  overlayShowSender             Boolean  @default(false)
  overlayMaxConcurrent          Int      @default(3)
  // Advanced OBS overlay appearance/animation settings (stored as JSON string)
  overlayStyleJson              String?  @db.Text
  // OBS overlay presets (per-channel, stored as JSON string; validated/size-limited by API)
  overlayPresetsJson            String?  @db.Text
  // Increment to invalidate previously issued overlay tokens.
  overlayTokenVersion           Int      @default(1)
  // === Dock ===
  dockTokenHash                 String?  @unique
  dockTokenVersion              Int      @default(1)
  // === Queue controls ===
  activationsEnabled            Boolean  @default(true) // intake pause
  overlayPlaybackPaused         Boolean  @default(false) // playback pause
  // === Queue state ===
  queueRevision                 Int      @default(0) // monotonic revision counter
  currentActivationId           String? // ID of current playing activation
  // Streamer dashboard layout (cross-device). Null => use frontend default order.
  // Stored as JSON array of card ids (strings). Normalized/validated by API.
  dashboardCardOrder            Json?    @db.JsonB
  // Economy settings (dynamic bonuses)
  economyMemesPerHour           Int      @default(2) // 1-10
  economyRewardMultiplier       Float    @default(1.0) // 0.5 - 2.0
  economyApprovalBonusCoins     Int      @default(0) // 0-100 (added to base approval reward)
  // Wheel of fortune settings
  wheelEnabled                  Boolean  @default(true)
  wheelPaidSpinCostCoins        Int?     // null => auto (50% of avg meme price)
  wheelPrizeMultiplier          Float    @default(1.0) // 0.5 - 2.0
  createdAt                     DateTime @default(now())

  users                        User[]
  wallets                      Wallet[]
  externalRewardEvents         ExternalRewardEvent[]
  pendingCoinGrants            PendingCoinGrant[]
  channelMemes                 ChannelMeme[]
  memeFavorites                UserMemeFavorite[]
  memeBlocklist                UserMemeBlocklist[]
  channelBlocklist             ChannelMemeBlocklist[]
  submissions                  MemeSubmission[]
  redemptions                  Redemption[]
  activations                  MemeActivation[]
  auditLogs                    AuditLog[]
  promotions                   Promotion[]
  dailyStats                   ChannelDailyStats[]
  userStats30d                 ChannelUserStats30d[]
  memeStats30d                 ChannelMemeStats30d[]
  memeDailyStats               ChannelMemeDailyStats[]
  chatBotSubscriptions         ChatBotSubscription[]
  chatBotOutboxMessages        ChatBotOutboxMessage[]
  chatBotEventDedups           ChatBotEventDedup[]
  vkVideoChatBotSubscriptions  VkVideoChatBotSubscription[]
  vkVideoChatBotOutboxMessages VkVideoChatBotOutboxMessage[]
  botIntegrations              BotIntegrationSettings[]
  youTubeChatBotSubscriptions  YouTubeChatBotSubscription[]
  youTubeChatBotOutboxMessages YouTubeChatBotOutboxMessage[]
  youTubeBotIntegration        YouTubeBotIntegration?
  vkVideoBotIntegration        VkVideoBotIntegration?
  twitchBotIntegration         TwitchBotIntegration?
  entitlements                 ChannelEntitlement[]
  streamSessions               StreamSession[]
  viewerEconomyStates          ChannelViewerEconomy[]
  achievements                 UserAchievement[]
  voteSessions                 MemeVoteSession[]
  wheelSpins                   WheelSpin[]
  submissionStreaks            ChannelSubmissionStreak[]
  eventAchievementGrants       UserEventAchievement[]
}

enum ExternalRewardProvider {
  vkvideo
  twitch
}

enum ExternalRewardEventType {
  vkvideo_channel_points_redemption
  twitch_channel_points_redemption
}

enum ExternalRewardCurrency {
  vkvideo_channel_points
  twitch_channel_points
}

enum ExternalRewardEventStatus {
  observed
  eligible
  ignored
  claimed
  failed
}

// Append-only (mostly) ledger of external reward events that may result in MemAlerts coin grants.
// IMPORTANT: This must NOT create new Users. Viewer identity is resolved later via account linking.
model ExternalRewardEvent {
  id                String                  @id @default(uuid())
  provider          ExternalRewardProvider
  // Unique event identifier within the provider (e.g. webhook message id / redemption id).
  providerEventId   String
  channelId         String
  providerAccountId String
  eventType         ExternalRewardEventType
  eventAt           DateTime?
  receivedAt        DateTime                @default(now())
  currency          ExternalRewardCurrency
  // Cost/value in provider currency units (e.g. channel points, mana).
  amount            Int
  status            ExternalRewardEventStatus @default(observed)
  reason            String?
  rawPayloadJson    String                  @db.Text
  updatedAt         DateTime                @updatedAt

  channel           Channel                 @relation(fields: [channelId], references: [id], onDelete: Cascade)
  pendingCoinGrant  PendingCoinGrant?
  webhookDeliveries ExternalWebhookDeliveryDedup[]

  @@unique([provider, providerEventId])
  @@index([channelId])
  @@index([provider, providerAccountId])
  @@index([provider, status])
  @@index([eventAt])
  @@index([receivedAt])
}

// Delivery-level dedupe for external webhooks.
// This is separate from ExternalRewardEvent dedupe (providerEventId), because providers may retry the same delivery.
model ExternalWebhookDeliveryDedup {
  id              String               @id @default(uuid())
  provider        ExternalRewardProvider
  messageId       String
  receivedAt      DateTime             @default(now())
  externalEventId String?

  externalEvent   ExternalRewardEvent? @relation(fields: [externalEventId], references: [id], onDelete: SetNull)

  @@unique([provider, messageId])
  @@index([receivedAt])
}

// Pending coin grants to be claimed when the viewer links their external account.
// Exactly-once invariant is enforced by unique externalEventId + claim update guard.
model PendingCoinGrant {
  id             String                @id @default(uuid())
  provider       ExternalRewardProvider
  providerAccountId String
  channelId      String
  externalEventId String              @unique
  coinsToGrant   Int
  createdAt      DateTime             @default(now())
  claimedAt      DateTime?
  claimedByUserId String?

  channel        Channel              @relation(fields: [channelId], references: [id], onDelete: Cascade)
  claimedBy      User?                @relation("PendingCoinGrantClaimedBy", fields: [claimedByUserId], references: [id], onDelete: SetNull)
  externalEvent  ExternalRewardEvent  @relation(fields: [externalEventId], references: [id], onDelete: Cascade)

  @@index([provider, providerAccountId])
  @@index([channelId])
  @@index([claimedAt])
  @@index([provider, providerAccountId, claimedAt])
}

// Channel-scoped feature entitlements (subscription gates / feature flags).
// Additive + safe for shared DB between prod/beta.
// Example key: "custom_bot" (allows per-channel bot sender override).
model ChannelEntitlement {
  id        String    @id @default(uuid())
  channelId String
  key       String
  enabled   Boolean   @default(true)
  expiresAt DateTime?
  source    String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, key])
  @@index([channelId])
  @@index([key, enabled])
  @@index([expiresAt])
}

enum BotIntegrationProvider {
  twitch
  vkplaylive
  vkvideo
  youtube
}

// Per-channel bot integration toggles (survive restarts/deploys).
// - twitch: gates ChatBotSubscription (Twitch IRC bot joins/parts)
// - vkplaylive: reserved for VKPlay Live chat integration (uses ENV mapping for now)
model BotIntegrationSettings {
  id        String                 @id @default(uuid())
  channelId String
  provider  BotIntegrationProvider
  enabled   Boolean                @default(false)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, provider])
  @@index([channelId])
  @@index([provider, enabled])
  @@index([enabled])
}

enum ExternalAccountProvider {
  twitch
  youtube
  vk
  vkvideo
  vkplay
}

enum StreamProvider {
  twitch
  vkvideo
  unknown
}

// VK Video Live chat bot subscriptions (global bot account joins many channels).
// Each MemAlerts Channel maps to a single VK Video Live channel identifier used by the chat connection.
model VkVideoChatBotSubscription {
  id                String   @id @default(uuid())
  channelId         String
  // Channel owner (used to access VKVideo API for roles; optional for backward compatibility).
  userId            String?
  vkvideoChannelId  String // platform channel identifier (exact format depends on VKVideo chat API)
  // Full channel URL on VK Video Live (required to resolve stream_id and websocket channel names via DevAPI).
  vkvideoChannelUrl String?
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([channelId])
  @@index([enabled])
  @@index([vkvideoChannelId])
  @@index([vkvideoChannelUrl])
  @@index([channelId])
  @@index([userId])
}

// VK Video Live chat bot outbox for sending messages via the separate vkvideo chatbot runner process.
model VkVideoChatBotOutboxMessage {
  id               String @id @default(uuid())
  channelId        String
  vkvideoChannelId String
  message          String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([vkvideoChannelId, status, createdAt])
  @@index([createdAt])
}


enum OAuthStateKind {
  login
  link
  bot_link
}

// Global Twitch IRC bot subscriptions (single bot account joins many channels).
model ChatBotSubscription {
  id          String   @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (for JOIN #login)
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([twitchLogin])
  @@index([channelId])
}

// YouTube chat bot subscriptions (per-channel, uses the streamer's linked YouTube account).
// Each MemAlerts Channel maps to a single YouTube channelId (owner's channel).
model YouTubeChatBotSubscription {
  id               String   @id @default(uuid())
  channelId        String
  userId           String
  youtubeChannelId String
  enabled          Boolean  @default(true)
  createdAt        DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([youtubeChannelId])
  @@index([userId])
  @@index([channelId])
}

// YouTube chat bot outbox for sending messages via the separate youtubeChatbotRunner process.
// API enqueues messages here; runner polls, delivers to YouTube Live Chat, then marks sent/failed.
model YouTubeChatBotOutboxMessage {
  id               String @id @default(uuid())
  channelId        String
  youtubeChannelId String
  message          String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([youtubeChannelId, status, createdAt])
  @@index([createdAt])
}

// Chat bot outbox for sending messages via the separate chatbotRunner process.
// API enqueues messages here; runner polls, delivers to Twitch IRC, then marks sent/failed.
model ChatBotOutboxMessage {
  id          String @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (target channel)
  message     String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([twitchLogin, status, createdAt])
  @@index([createdAt])
}

// Dedupe table for chat-bot-triggering events (e.g., EventSub follow) to prevent duplicate greetings.
model ChatBotEventDedup {
  id        String   @id @default(uuid())
  channelId String
  kind      String // e.g. "follow"
  eventId   String
  createdAt DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([kind, eventId])
  @@index([channelId])
  @@index([kind])
  @@index([createdAt])
}

// Per-user cross-device UI preferences.
// NOTE: kept additive and isolated to a single row per user (no channel dimension).
model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  theme                String   @default("light") // light | dark
  autoplayMemesEnabled Boolean  @default(true)
  memeModalMuted       Boolean  @default(false)
  coinsInfoSeen        Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id                 String   @id @default(uuid())
  // Legacy: Twitch user id. Optional to support non-Twitch identities in the future.
  twitchUserId       String?  @unique
  displayName        String
  profileImageUrl    String? // Twitch profile image URL
  role               String // viewer, streamer, admin
  channelId          String?
  twitchAccessToken  String? // Twitch OAuth access token for API calls
  twitchRefreshToken String? // Twitch OAuth refresh token
  hasBetaAccess      Boolean  @default(false) // Beta access flag
  createdAt          DateTime @default(now())

  channel                     Channel?                     @relation(fields: [channelId], references: [id], onDelete: SetNull)
  preference                  UserPreference?
  externalAccounts            ExternalAccount[]
  oauthStates                 OAuthState[]
  youTubeChatBotSubscriptions YouTubeChatBotSubscription[]
  vkVideoChatBotSubscriptions VkVideoChatBotSubscription[]
  wallets                     Wallet[]
  pendingCoinGrantsClaimed    PendingCoinGrant[]         @relation("PendingCoinGrantClaimedBy")
  memeAssetsCreated           MemeAsset[]
  submissions                 MemeSubmission[]
  redemptions                 Redemption[]
  activations                 MemeActivation[]
  channelStats30d             ChannelUserStats30d[]
  auditLogs                   AuditLog[]
  betaAccess                  BetaAccess?
  globalModerator             GlobalModerator?
  moderatorsGranted           GlobalModerator[]            @relation("GlobalModeratorGrantedBy")
  moderatorsRevoked           GlobalModerator[]            @relation("GlobalModeratorRevokedBy")
  banState                    UserBanState?
  tasteProfile                UserTasteProfile?
  tagActivities               UserTagActivity[]
  tagSuggestionsReviewed      TagSuggestion[]              @relation("TagSuggestionReviewedBy")
  memeFavorites               UserMemeFavorite[]
  memeBlocklist               UserMemeBlocklist[]
  channelBlocklistCreated     ChannelMemeBlocklist[]       @relation("ChannelBlocklistCreatedBy")
  viewerEconomyStates         ChannelViewerEconomy[]
  achievements                UserAchievement[]
  voteSessionsCreated         MemeVoteSession[]
  voteBallots                 MemeVoteBallot[]
  wheelSpins                  WheelSpin[]
  submissionStreaks           ChannelSubmissionStreak[]
  eventAchievements           UserEventAchievement[]

  @@index([twitchUserId])
  @@index([channelId])
  @@index([hasBetaAccess])
}

// Global moderator permission (does NOT change User.role).
// Used for shared meme pool moderation (MemeAsset visibility + quarantine deletion).
model GlobalModerator {
  id              String   @id @default(uuid())
  userId          String   @unique
  grantedAt       DateTime @default(now())
  grantedByUserId String?
  revokedAt       DateTime?
  revokedByUserId String?

  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  grantedBy User? @relation("GlobalModeratorGrantedBy", fields: [grantedByUserId], references: [id], onDelete: SetNull)
  revokedBy User? @relation("GlobalModeratorRevokedBy", fields: [revokedByUserId], references: [id], onDelete: SetNull)

  @@index([grantedAt])
  @@index([revokedAt])
}

model ExternalAccount {
  id                String                  @id @default(uuid())
  userId            String
  provider          ExternalAccountProvider
  providerAccountId String

  // Profile-ish fields (best-effort, provider-dependent)
  displayName String?
  login       String?
  avatarUrl   String?
  profileUrl  String?

  // OAuth tokens (optional; some providers may not return refresh tokens etc.)
  accessToken    String?
  refreshToken   String?
  // Some providers use refresh token + device id.
  deviceId       String?
  tokenExpiresAt DateTime?
  scopes         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user                       User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  youTubeBotIntegration      YouTubeBotIntegration?
  globalYouTubeBotCredential GlobalYouTubeBotCredential?
  vkVideoBotIntegration      VkVideoBotIntegration?
  globalVkVideoBotCredential GlobalVkVideoBotCredential?
  twitchBotIntegration       TwitchBotIntegration?
  globalTwitchBotCredential  GlobalTwitchBotCredential?

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
  @@index([providerAccountId])
}

model OAuthState {
  // Random state string used as primary key (stored server-side for verification)
  state    String                  @id
  provider ExternalAccountProvider
  kind     OAuthStateKind

  // For link flows: the authenticated user that initiated linking.
  userId    String?
  // For bot_link flows: channelId of the streamer who initiated linking.
  channelId String?

  // Redirect handling
  redirectTo String?
  origin     String?

  // PKCE-ready (not used for Twitch currently, but stored for future providers)
  codeVerifier String?

  expiresAt  DateTime
  consumedAt DateTime?

  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([provider, kind])
  @@index([userId])
  @@index([channelId])
}

// Optional per-channel YouTube "bot account" override.
// If present, YouTube chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global YouTube bot token (YOUTUBE_BOT_REFRESH_TOKEN).
model YouTubeBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared YouTube bot credential (single "default MemAlerts bot" account).
// Linked by admin once; used as sender for YouTube chat messages when a channel has no override.
model GlobalYouTubeBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

// Optional per-channel VKVideo "bot account" override.
// If present, VKVideo chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global VKVideo bot credential.
model VkVideoBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared VKVideo bot credential (single default MemAlerts bot account).
// Linked by admin once; used as sender for VKVideo chat messages when a channel has no override.
model GlobalVkVideoBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

// Optional per-channel Twitch "bot account" override.
// If present, Twitch chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global Twitch bot credential.
model TwitchBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared Twitch bot credential (single default MemAlerts bot account).
// Linked by admin once; used as sender for Twitch chat messages when a channel has no override.
model GlobalTwitchBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

// Lightweight heartbeat table for background workers (bots/AI).
// No foreign keys to keep it expand-only and deployment-safe.
model ServiceHeartbeat {
  id         String   @id
  lastSeenAt DateTime @updatedAt
  meta       Json?    @db.JsonB
  createdAt  DateTime @default(now())

  @@index([lastSeenAt])
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String
  channelId String
  balance   Int      @default(0)
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
}

// Stream sessions for economy calculations (best-effort, based on online/offline signals).
model StreamSession {
  id        String    @id @default(uuid())
  channelId String
  provider  StreamProvider @default(unknown)
  startedAt DateTime
  endedAt   DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  viewerEconomyStates ChannelViewerEconomy[]

  @@index([channelId, startedAt])
  @@index([channelId, endedAt])
  @@index([provider, startedAt])
}

// Per-channel viewer economy state (daily/watch bonuses and start bonus).
model ChannelViewerEconomy {
  id                     String   @id @default(uuid())
  channelId              String
  userId                 String
  dailyBonusLastClaimAt  DateTime?
  watchBonusLastClaimAt  DateTime?
  loginStreakLastClaimAt DateTime?
  loginStreakCount       Int      @default(0)
  watchBonusClaimCount   Int      @default(0)
  watchBonusSessionId    String?
  wheelFreeSpinLastAt    DateTime?
  linkedProviders        String[] @default([])
  startBonusGrantedAt    DateTime?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  channel    Channel       @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchBonusSession StreamSession? @relation(fields: [watchBonusSessionId], references: [id], onDelete: SetNull)

  @@unique([channelId, userId])
  @@index([userId])
  @@index([channelId])
  @@index([watchBonusSessionId])
  @@index([dailyBonusLastClaimAt])
  @@index([watchBonusLastClaimAt])
  @@index([loginStreakLastClaimAt])
  @@index([wheelFreeSpinLastAt])
}

// Global media file shared across channels.
model MemeAsset {
  id              String   @id @default(uuid())

  // Media
  type            String   // 'video' | 'audio' | 'image'
  fileUrl         String   // Primary playback URL
  fileHash        String   @unique // SHA-256 for dedup
  mimeType        String?
  fileSizeBytes   BigInt?
  durationMs      Int      @default(0)

  // Variants for different formats
  variants        MemeAssetVariant[]

  // AI enrichment
  aiStatus          String   @default("pending") // 'pending' | 'processing' | 'done' | 'failed'
  aiAutoTitle       String?
  aiAutoDescription String?  @db.Text
  aiAutoTagNames    String[] // Array of tag names
  aiTranscript      String?  @db.Text
  aiSearchText      String?  @db.Text
  aiCompletedAt     DateTime?
  aiRiskScore       Float?

  // Quality
  qualityScore    Float?   // 0-100

  // Status
  status          String   @default("active") // 'active' | 'hidden' | 'quarantined' | 'deleted'
  hiddenAt        DateTime?
  quarantinedAt   DateTime?
  deletedAt       DateTime?

  // Relations
  channelMemes    ChannelMeme[]
  submissions     MemeSubmission[]
  tagSuggestions  TagSuggestion[]
  favoritedBy     UserMemeFavorite[]
  blockedByUsers  UserMemeBlocklist[]
  blockedByChannels ChannelMemeBlocklist[]
  /// Co-occurrence связи (этот мем как первый в паре)
  cooccurrencesAs1 MemeCooccurrence[] @relation("CooccurrenceMeme1")
  /// Co-occurrence связи (этот мем как второй в паре)
  cooccurrencesAs2 MemeCooccurrence[] @relation("CooccurrenceMeme2")
  globalStats30d  GlobalMemeStats30d?
  globalDailyStats GlobalMemeDailyStats[]
  createdById     String?
  createdBy       User?    @relation(fields: [createdById], references: [id])

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([fileHash])
  @@index([status])
  @@index([aiStatus])
  @@index([qualityScore])
  @@index([createdAt])
}

/// Хранит количество совместных активаций пар мемов
/// Если пользователь активировал мем A и мем B — это co-occurrence
model MemeCooccurrence {
  id            String    @id @default(cuid())

  /// ID первого мема (всегда меньший по алфавиту для уникальности)
  memeAssetId1  String
  memeAsset1    MemeAsset @relation("CooccurrenceMeme1", fields: [memeAssetId1], references: [id], onDelete: Cascade)

  /// ID второго мема
  memeAssetId2  String
  memeAsset2    MemeAsset @relation("CooccurrenceMeme2", fields: [memeAssetId2], references: [id], onDelete: Cascade)

  /// Количество пользователей, активировавших оба мема
  cooccurrences Int       @default(0)

  /// Последнее обновление
  updatedAt     DateTime  @updatedAt

  @@unique([memeAssetId1, memeAssetId2])
  @@index([memeAssetId1])
  @@index([memeAssetId2])
  @@index([cooccurrences])
}

model UserBanState {
  id              String   @id @default(uuid())
  userId          String   @unique
  banCount        Int      @default(0)
  currentBanUntil DateTime?
  lastBanAt       DateTime?
  banDecayAt      DateTime?
  reason          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MemeAssetVariant {
  id              String   @id @default(uuid())
  memeAssetId     String
  memeAsset       MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  format          String   // 'webm' | 'mp4' | 'preview'
  fileUrl         String
  status          String   @default("pending") // 'pending' | 'processing' | 'done' | 'failed'
  priority        Int      @default(0) // Lower = preferred
  fileSizeBytes   BigInt?

  createdAt       DateTime @default(now())

  @@unique([memeAssetId, format])
  @@index([memeAssetId, status])
}

// Channel-specific meme entry in catalog.
model ChannelMeme {
  id              String   @id @default(uuid())
  channelId       String
  channel         Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  memeAssetId     String
  memeAsset       MemeAsset @relation(fields: [memeAssetId], references: [id])

  // Display
  title           String   // Channel-specific title (can differ from AI)

  // Pricing
  priceCoins      Int      @default(100)

  // Cooldown
  cooldownMinutes Int?     // null = no cooldown
  lastActivatedAt DateTime?
  timingBonusLastAt DateTime?

  // Status
  status          String   @default("approved") // 'approved' | 'pending' | 'rejected' | 'disabled'

  // Soft delete
  deletedAt       DateTime?

  // Relations
  activations     MemeActivation[]
  tags            ChannelMemeTag[]
  stats30d        ChannelMemeStats30d[]
  dailyStats      ChannelMemeDailyStats[]
  voteOptions     MemeVoteOption[]
  voteBallots     MemeVoteBallot[]
  voteWins        MemeVoteSession[]
  viralBonuses    MemeViralBonus[]

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([channelId, memeAssetId])
  @@index([channelId, status, deletedAt])
  @@index([memeAssetId])
  @@index([createdAt])
}

model MemeSubmission {
  id              String   @id @default(uuid())
  channelId       String
  submitterUserId String
  title           String
  type            String // image, gif, video, audio
  fileUrlTemp     String
  sourceUrl       String? // URL of imported meme from memalerts.com
  memeAssetId     String? // Pool import: references MemeAsset
  sourceKind      String   @default("upload") // upload | url | pool
  notes           String?
  idempotencyKey  String?  @db.VarChar(128)
  status          String // pending, approved, rejected
  moderatorNotes  String?
  // Upload metadata (best-effort; required for AI and better moderation UX).
  fileHash      String? @db.VarChar(64)
  durationMs    Int?
  mimeType      String? @db.VarChar(64)
  fileSizeBytes Int?

  // AI moderation pipeline state (best-effort; safe defaults for backfill).
  aiStatus           String   @default("pending") // pending|processing|done|failed
  aiDecision         String?  @db.VarChar(16)     // low|medium|high
  aiRiskScore        Float?
  aiLabelsJson       Json?
  aiTranscript       String?  @db.VarChar(50000)
  aiAutoTagNamesJson Json?
  aiAutoDescription  String?  @db.VarChar(2000)
  aiModelVersionsJson Json?
  aiCompletedAt      DateTime?
  aiRetryCount       Int      @default(0)
  aiLastTriedAt      DateTime?
  // Lock/processing fields (used for distributed queue safety).
  aiProcessingStartedAt DateTime?
  aiLockedBy         String?  @db.VarChar(128)
  aiLockExpiresAt    DateTime?
  aiNextRetryAt      DateTime?
  aiError            String?  @db.Text
  // Number of times the submitter resubmitted this submission after "needs_changes".
  // Used to enforce a small iteration limit for scale (prevents infinite loops).
  revision        Int      @default(0)
  createdAt       DateTime @default(now())

  channel   Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  submitter User                @relation(fields: [submitterUserId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset?          @relation(fields: [memeAssetId], references: [id], onDelete: SetNull)
  tags      MemeSubmissionTag[]

  @@index([channelId])
  @@index([status])
  @@index([submitterUserId])
  @@index([memeAssetId])
  @@index([sourceKind])
  @@index([fileHash])
  @@index([status, sourceKind, aiStatus, aiNextRetryAt, createdAt])
  @@index([aiStatus, aiLockExpiresAt])
  @@index([channelId, status, createdAt(sort: Desc)])
  @@index([submitterUserId, status, createdAt(sort: Desc)])
  @@index([submitterUserId, createdAt(sort: Desc)])
  @@unique([channelId, submitterUserId, idempotencyKey])
  @@unique([channelId, memeAssetId, status])
}

model Redemption {
  id                 String   @id @default(uuid())
  channelId          String
  userId             String
  twitchRedemptionId String   @unique
  pointsSpent        Int
  coinsGranted       Int
  status             String // pending, completed, failed
  createdAt          DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([twitchRedemptionId])
}

model MemeActivation {
  id              String   @id @default(uuid())
  channelMemeId   String
  channelMeme     ChannelMeme @relation(fields: [channelMemeId], references: [id])
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  channelId       String
  channel         Channel  @relation(fields: [channelId], references: [id])

  // Transaction
  priceCoins      Int
  volume          Float    @default(1)

  // Status
  status          String   @default("queued") // 'queued' | 'playing' | 'done' | 'skipped' | 'cancelled'

  // End state
  endedAt         DateTime? // when it ended (any reason)
  endedReason     String? // 'natural' | 'skipped_by_streamer' | 'skipped_by_mod' | 'cleared' | 'error' | 'timeout'
  endedById       String? // who ended it (userId)
  endedByRole     String? // 'streamer' | 'mod' | 'system'
  refundedAt      DateTime? // refund applied (priceCoins)

  // Timestamps
  createdAt       DateTime @default(now())
  playedAt        DateTime?
  completedAt     DateTime?

  @@index([channelMemeId, status])
  @@index([userId, createdAt])
  @@index([channelId, createdAt])
  @@index([channelId, status, createdAt])
}

model MemeVoteSession {
  id                 String   @id @default(uuid())
  channelId          String
  status             String   @default("active") // active | ended | cancelled
  startedAt          DateTime @default(now())
  endsAt             DateTime?
  endedAt            DateTime?
  createdByUserId    String?
  winnerChannelMemeId String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  channel      Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  createdBy    User?        @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  winnerMeme   ChannelMeme? @relation(fields: [winnerChannelMemeId], references: [id], onDelete: SetNull)
  options      MemeVoteOption[]
  ballots      MemeVoteBallot[]

  @@index([channelId, status])
  @@index([startedAt])
  @@index([endsAt])
}

model MemeVoteOption {
  id            String   @id @default(uuid())
  sessionId     String
  channelMemeId String
  optionIndex   Int

  session      MemeVoteSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  channelMeme  ChannelMeme     @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)

  @@unique([sessionId, optionIndex])
  @@index([sessionId])
  @@index([channelMemeId])
}

model MemeVoteBallot {
  id            String   @id @default(uuid())
  sessionId     String
  userId        String
  channelMemeId String
  createdAt     DateTime @default(now())

  session     MemeVoteSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  channelMeme ChannelMeme     @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([channelMemeId])
}

model WheelSpin {
  id         String   @id @default(uuid())
  channelId  String
  userId     String
  isFree     Boolean  @default(false)
  costCoins  Int      @default(0)
  prizeTier  String
  prizeCoins Int
  prizeLabel String?
  createdAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([channelId, createdAt])
  @@index([userId, createdAt])
}

model ChannelSubmissionStreak {
  id             String   @id @default(uuid())
  channelId      String
  userId         String
  streakCount    Int      @default(0)
  lastApprovedAt DateTime?
  lastRejectedAt DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([channelId])
  @@index([userId])
}

model MemeViralBonus {
  id            String   @id @default(uuid())
  channelMemeId String
  threshold     Int
  awardedAt     DateTime @default(now())

  channelMeme ChannelMeme @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)

  @@unique([channelMemeId, threshold])
  @@index([channelMemeId])
}

model UserMemeFavorite {
  id          String   @id @default(uuid())
  userId      String
  channelId   String
  memeAssetId String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId, memeAssetId])
  @@index([userId])
  @@index([channelId])
  @@index([memeAssetId])
  @@index([channelId, userId])
}

model UserMemeBlocklist {
  id          String   @id @default(uuid())
  userId      String
  channelId   String
  memeAssetId String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId, memeAssetId])
  @@index([userId])
  @@index([channelId])
  @@index([memeAssetId])
  @@index([channelId, userId])
}

model UserAchievement {
  id         String   @id @default(uuid())
  userId     String
  channelId  String?
  key        String
  achievedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId, key])
  @@index([userId])
  @@index([channelId])
  @@index([key])
  @@index([achievedAt])
}

model ChannelMemeBlocklist {
  id              String   @id @default(uuid())
  channelId       String
  memeAssetId     String
  createdByUserId String?
  reason          String?  @db.VarChar(500)
  createdAt       DateTime @default(now())

  channel   Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)
  createdBy User?     @relation("ChannelBlocklistCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@unique([channelId, memeAssetId])
  @@index([channelId])
  @@index([memeAssetId])
  @@index([createdByUserId])
}

model AuditLog {
  id          String   @id @default(uuid())
  actorId     String?
  channelId   String
  action      String
  payloadJson String   @db.Text
  createdAt   DateTime @default(now())

  actor   User?   @relation(fields: [actorId], references: [id], onDelete: SetNull)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([actorId])
  @@index([createdAt])
}

model Tag {
  id          String   @id @default(uuid())
  name        String   @unique
  displayName String?
  categoryId  String?
  status      String   @default("active") // 'active' | 'deprecated'
  usageCount  Int      @default(0)
  createdAt   DateTime @default(now())

  category   TagCategory? @relation(fields: [categoryId], references: [id])
  aliases    TagAlias[]
  channelMemeTags ChannelMemeTag[]
  mappedSuggestions TagSuggestion[] @relation("TagSuggestionMappedTo")
  tagActivities UserTagActivity[]
  submissions MemeSubmissionTag[]

  @@index([categoryId])
  @@index([status, usageCount])
}

model TagCategory {
  id          String   @id @default(uuid())
  slug        String   @unique
  displayName String
  sortOrder   Int      @default(0)

  tags Tag[]

  @@index([sortOrder])
}

model TagAlias {
  id        String   @id @default(uuid())
  alias     String   @unique
  tagId     String

  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([tagId])
}

model ChannelMemeTag {
  id              String   @id @default(uuid())
  channelMemeId   String
  channelMeme     ChannelMeme @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)
  tagId           String
  tag             Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([channelMemeId, tagId])
  @@index([tagId])
}

model TagSuggestion {
  id            String   @id @default(uuid())
  rawTag        String
  normalizedTag String   @unique
  memeAssetId   String?
  count         Int      @default(1)
  status        String   @default("pending") // pending | approved | rejected | mapped
  mappedToTagId String?
  createdAt     DateTime @default(now())
  reviewedAt    DateTime?
  reviewedById  String?

  memeAsset  MemeAsset? @relation(fields: [memeAssetId], references: [id], onDelete: SetNull)
  mappedTo   Tag?       @relation("TagSuggestionMappedTo", fields: [mappedToTagId], references: [id], onDelete: SetNull)
  reviewedBy User?      @relation("TagSuggestionReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)

  @@index([status, count])
}

model UserTasteProfile {
  id                 String   @id @default(uuid())
  userId             String   @unique
  tagWeightsJson     Json     @default("{}")
  categoryWeightsJson Json    @default("{}")
  topTagsJson        Json     @default("[]")
  totalActivations   Int      @default(0)
  profileVersion     Int      @default(1)
  lastActivationAt   DateTime?
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserTagActivity {
  id        String   @id @default(uuid())
  userId    String
  tagId     String
  weight    Float    @default(1.0)
  source    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([userId, tagId])
  @@index([userId, createdAt])
}

model MemeSubmissionTag {
  id           String @id @default(uuid())
  submissionId String
  tagId        String

  submission MemeSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  tag        Tag            @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([submissionId, tagId])
  @@index([submissionId])
  @@index([tagId])
}

model Promotion {
  id              String   @id @default(uuid())
  channelId       String
  name            String
  discountPercent Float // 0-100, e.g., 50 for 50% discount
  startDate       DateTime
  endDate         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([isActive])
  @@index([startDate, endDate])
}

model SeasonalEvent {
  id          String   @id @default(uuid())
  key         String   @unique
  title       String
  description String?  @db.Text
  startsAt    DateTime
  endsAt      DateTime
  themeJson   String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  achievements EventAchievement[]

  @@index([startsAt, endsAt])
}

model EventAchievement {
  id               String   @id @default(uuid())
  eventId          String
  key              String
  title            String
  description      String?  @db.Text
  targetActivations Int?
  rewardCoins      Int?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  event   SeasonalEvent        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  grants  UserEventAchievement[]

  @@unique([eventId, key])
  @@index([eventId])
}

model UserEventAchievement {
  id                  String   @id @default(uuid())
  eventAchievementId  String
  userId              String
  channelId           String?
  achievedAt          DateTime @default(now())

  eventAchievement EventAchievement @relation(fields: [eventAchievementId], references: [id], onDelete: Cascade)
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel         Channel?          @relation(fields: [channelId], references: [id], onDelete: SetNull)

  @@unique([eventAchievementId, userId])
  @@index([eventAchievementId])
  @@index([userId])
  @@index([channelId])
  @@index([achievedAt])
}

model FileHash {
  hash           String   @id // SHA-256 hash
  filePath       String // Path to physical file
  referenceCount Int      @default(1) // Number of references to this file
  fileSize       BigInt // File size in bytes
  mimeType       String // MIME type of the file
  createdAt      DateTime @default(now())

  @@index([referenceCount])
}

model BetaAccess {
  id          String    @id @default(uuid())
  userId      String    @unique
  status      String // pending, approved, rejected
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  approvedBy  String? // User ID who approved/rejected
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

// Rollup / pre-aggregations for performance at scale.
// These tables are additive and safe for shared DB (beta+prod) when deployed with expand/contract strategy.
model ChannelDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC

  // All statuses (queued/playing/done/failed/etc). Mirrors admin daily chart semantics.
  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)

  // Completed-only (done/completed). Mirrors viewer stats semantics.
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  // Best-effort unique user counts (all statuses / completed).
  uniqueUsersCountAll       Int @default(0)
  uniqueUsersCountCompleted Int @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@id([channelId, day])
  @@index([channelId, day])
  @@index([day])
}

// 30-day rolling window rollups (min-load strategy):
// keep expensive groupBy queries off the hot path by precomputing aggregates on a fixed window.
model ChannelUserStats30d {
  channelId String
  userId    String

  // Window boundaries (UTC). Informational; recomputed by job.
  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId])
  @@index([channelId])
  @@index([channelId, totalCoinsSpentSum])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model ChannelMemeStats30d {
  channelId String
  channelMemeId String

  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel     Channel    @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelMeme ChannelMeme @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)

  @@id([channelId, channelMemeId])
  @@index([channelId])
  @@index([channelId, completedActivationsCount])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model GlobalMemeStats30d {
  memeAssetId String

  windowStart DateTime
  windowEnd   DateTime

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  @@id([memeAssetId])
  @@index([completedActivationsCount])
  @@index([updatedAt])
}

// Daily rollups for viewer stats (day/week/month aggregation without scanning MemeActivation).
model ChannelMemeDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC
  channelMemeId String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel     Channel    @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelMeme ChannelMeme @relation(fields: [channelMemeId], references: [id], onDelete: Cascade)

  @@id([channelId, day, channelMemeId])
  @@index([channelId, day])
  @@index([channelId, channelMemeId])
  @@index([day])
}

model GlobalMemeDailyStats {
  day    DateTime // date_trunc('day', createdAt) in UTC
  memeAssetId String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  @@id([day, memeAssetId])
  @@index([day])
  @@index([memeAssetId])
}
