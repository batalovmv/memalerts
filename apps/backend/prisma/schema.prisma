generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id                String   @id @default(uuid())
  twitchChannelId   String   @unique
  slug              String   @unique
  name              String
  rewardIdForCoins  String?
  coinPerPointRatio Float    @default(1.0)
  rewardEnabled     Boolean  @default(false) // Is reward enabled/active
  rewardTitle       String? // Title of the reward in Twitch
  rewardCost        Int? // Cost in channel points
  rewardCoins       Int? // Coins granted per redemption
  // If true, coins for the Twitch channel points reward are granted only when stream is online.
  rewardOnlyWhenLive Boolean @default(false)
  coinIconUrl       String? // Custom coin icon URL from Twitch reward
  primaryColor      String? // Hex color for primary theme
  secondaryColor    String? // Hex color for secondary theme
  accentColor       String? // Hex color for accent
  defaultPriceCoins Int?    @default(100) // Default price for memes in this channel
  submissionRewardCoins Int @default(0) // Coins granted to submitter when their submission is approved
  // If true, submission approval coins are granted only when stream is online.
  submissionRewardOnlyWhenLive Boolean @default(false)
  // OBS overlay settings (server-side defaults for tokenized overlay URLs)
  overlayMode       String  @default("queue") // queue | simultaneous
  overlayShowSender Boolean @default(false)
  overlayMaxConcurrent Int  @default(3)
  // Advanced OBS overlay appearance/animation settings (stored as JSON string)
  overlayStyleJson  String?  @db.Text
  // OBS overlay presets (per-channel, stored as JSON string; validated/size-limited by API)
  overlayPresetsJson String? @db.Text
  // Increment to invalidate previously issued overlay tokens.
  overlayTokenVersion Int @default(1)
  // OBS credits overlay (titres) settings (stored as JSON string)
  creditsStyleJson  String?  @db.Text
  // Increment to invalidate previously issued credits tokens.
  creditsTokenVersion Int @default(1)
  // Credits session reconnect window in minutes (keep session alive after stream goes offline / bot disconnects).
  creditsReconnectWindowMinutes Int @default(60)
  // Chat bot "smart" command: stream duration settings (stored as JSON string; validated by API).
  streamDurationCommandJson String? @db.Text
  // Chat bot follow greeting settings
  followGreetingsEnabled Boolean @default(false)
  followGreetingTemplate String? @db.Text
  createdAt         DateTime @default(now())

  users       User[]
  wallets     Wallet[]
  memes       Meme[]
  submissions MemeSubmission[]
  redemptions Redemption[]
  activations MemeActivation[]
  auditLogs   AuditLog[]
  promotions  Promotion[]
  dailyStats  ChannelDailyStats[]
  userStats30d ChannelUserStats30d[]
  memeStats30d ChannelMemeStats30d[]
  memeDailyStats ChannelMemeDailyStats[]
  chatBotSubscriptions ChatBotSubscription[]
  chatBotOutboxMessages ChatBotOutboxMessage[]
  chatBotCommands ChatBotCommand[]
  chatBotEventDedups ChatBotEventDedup[]
}

// Global Twitch IRC bot subscriptions (single bot account joins many channels).
model ChatBotSubscription {
  id         String   @id @default(uuid())
  channelId  String
  twitchLogin String  // lowercase twitch channel login (for JOIN #login)
  enabled    Boolean  @default(true)
  createdAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([twitchLogin])
  @@index([channelId])
}

// Chat bot outbox for sending messages via the separate chatbotRunner process.
// API enqueues messages here; runner polls, delivers to Twitch IRC, then marks sent/failed.
model ChatBotOutboxMessage {
  id          String   @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (target channel)
  message     String  @db.Text

  status      String  @default("pending") // pending | processing | sent | failed
  attempts    Int     @default(0)
  lastError   String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([twitchLogin, status, createdAt])
  @@index([createdAt])
}

// Per-channel chat bot commands (trigger -> response).
model ChatBotCommand {
  id                String   @id @default(uuid())
  channelId          String
  trigger            String
  triggerNormalized  String
  response           String  @db.Text
  enabled            Boolean @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, triggerNormalized])
  @@index([channelId])
  @@index([enabled])
  @@index([channelId, enabled])
  @@index([triggerNormalized])
}

// Dedupe table for chat-bot-triggering events (e.g., EventSub follow) to prevent duplicate greetings.
model ChatBotEventDedup {
  id        String   @id @default(uuid())
  channelId String
  kind      String   // e.g. "follow"
  eventId   String
  createdAt DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([kind, eventId])
  @@index([channelId])
  @@index([kind])
  @@index([createdAt])
}

// Per-user cross-device UI preferences.
// NOTE: kept additive and isolated to a single row per user (no channel dimension).
model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  theme                String   @default("light") // light | dark
  autoplayMemesEnabled Boolean  @default(true)
  memeModalMuted       Boolean  @default(false)
  coinsInfoSeen        Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id                 String   @id @default(uuid())
  twitchUserId       String   @unique
  displayName        String
  profileImageUrl    String? // Twitch profile image URL
  role               String // viewer, streamer, admin
  channelId          String?
  twitchAccessToken  String? // Twitch OAuth access token for API calls
  twitchRefreshToken String? // Twitch OAuth refresh token
  hasBetaAccess      Boolean  @default(false) // Beta access flag
  createdAt          DateTime @default(now())

  channel       Channel?         @relation(fields: [channelId], references: [id], onDelete: SetNull)
  preference    UserPreference?
  wallets       Wallet[]
  memesCreated  Meme[]           @relation("CreatedBy")
  memesApproved Meme[]           @relation("ApprovedBy")
  submissions   MemeSubmission[]
  redemptions   Redemption[]
  activations   MemeActivation[]
  channelStats30d ChannelUserStats30d[]
  auditLogs     AuditLog[]
  betaAccess    BetaAccess?

  @@index([twitchUserId])
  @@index([channelId])
  @@index([hasBetaAccess])
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String
  channelId String
  balance   Int      @default(0)
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
}

model Meme {
  id               String   @id @default(uuid())
  channelId        String
  title            String
  type             String // image, gif, video, audio
  fileUrl          String
  fileHash         String? // SHA-256 hash for deduplication
  durationMs       Int
  priceCoins       Int
  status           String // pending, approved, rejected
  deletedAt        DateTime?
  createdByUserId  String?
  approvedByUserId String?
  createdAt        DateTime @default(now())

  channel     Channel          @relation(fields: [channelId], references: [id], onDelete: Cascade)
  createdBy   User?            @relation("CreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  approvedBy  User?            @relation("ApprovedBy", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  activations MemeActivation[]
  globalStats30d GlobalMemeStats30d?
  globalDailyStats GlobalMemeDailyStats[]
  tags        MemeTag[]
  channelStats30d ChannelMemeStats30d[]
  channelDailyStats ChannelMemeDailyStats[]
  fileHashRef FileHash?        @relation(fields: [fileHash], references: [hash], onDelete: SetNull)

  @@index([channelId])
  @@index([status])
  @@index([deletedAt])
  @@index([createdByUserId])
  @@index([fileHash])
  // Common read pattern: list approved memes for a channel ordered by createdAt
  @@index([channelId, status, createdAt])
}

model MemeSubmission {
  id              String   @id @default(uuid())
  channelId       String
  submitterUserId String
  title           String
  type            String // image, gif, video, audio
  fileUrlTemp     String
  sourceUrl       String? // URL of imported meme from memalerts.com
  notes           String?
  status          String // pending, approved, rejected
  moderatorNotes  String?
  // Number of times the submitter resubmitted this submission after "needs_changes".
  // Used to enforce a small iteration limit for scale (prevents infinite loops).
  revision        Int      @default(0)
  createdAt       DateTime @default(now())

  channel   Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  submitter User                @relation(fields: [submitterUserId], references: [id], onDelete: Cascade)
  tags      MemeSubmissionTag[]

  @@index([channelId])
  @@index([status])
  @@index([submitterUserId])
}

model Redemption {
  id                 String   @id @default(uuid())
  channelId          String
  userId             String
  twitchRedemptionId String   @unique
  pointsSpent        Int
  coinsGranted       Int
  status             String // pending, completed, failed
  createdAt          DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([twitchRedemptionId])
}

model MemeActivation {
  id         String   @id @default(uuid())
  channelId  String
  userId     String
  memeId     String
  coinsSpent Int
  status     String // queued, playing, done, failed
  createdAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([status])
  @@index([memeId])
  // Common time-range scans (e.g., daily charts / rollups)
  @@index([channelId, createdAt])
  // Admin stats groupBy helpers (group by userId/memeId within a channel)
  @@index([channelId, userId])
  @@index([channelId, memeId])
  // Query helpers:
  // - popularity ranking: filter by channelId + status + createdAt, group by memeId
  @@index([channelId, status, createdAt, memeId])
  // - favorites ranking: filter by channelId + userId + status, group by memeId
  @@index([channelId, userId, status, memeId])
}

model AuditLog {
  id          String   @id @default(uuid())
  actorId     String?
  channelId   String
  action      String
  payloadJson String   @db.Text
  createdAt   DateTime @default(now())

  actor   User?   @relation(fields: [actorId], references: [id], onDelete: SetNull)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([actorId])
  @@index([createdAt])
}

model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  memes       MemeTag[]
  submissions MemeSubmissionTag[]

  @@index([name])
}

model MemeTag {
  id     String @id @default(uuid())
  memeId String
  tagId  String

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([memeId, tagId])
  @@index([memeId])
  @@index([tagId])
}

model MemeSubmissionTag {
  id           String @id @default(uuid())
  submissionId String
  tagId        String

  submission MemeSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  tag        Tag            @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([submissionId, tagId])
  @@index([submissionId])
  @@index([tagId])
}

model Promotion {
  id              String   @id @default(uuid())
  channelId       String
  name            String
  discountPercent Float // 0-100, e.g., 50 for 50% discount
  startDate       DateTime
  endDate         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([isActive])
  @@index([startDate, endDate])
}

model FileHash {
  hash           String   @id // SHA-256 hash
  filePath       String // Path to physical file
  referenceCount Int      @default(1) // Number of references to this file
  fileSize       BigInt // File size in bytes
  mimeType       String // MIME type of the file
  createdAt      DateTime @default(now())

  memes Meme[]

  @@index([referenceCount])
}

model BetaAccess {
  id          String    @id @default(uuid())
  userId      String    @unique
  status      String // pending, approved, rejected
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  approvedBy  String? // User ID who approved/rejected
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

// Rollup / pre-aggregations for performance at scale.
// These tables are additive and safe for shared DB (beta+prod) when deployed with expand/contract strategy.
model ChannelDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC

  // All statuses (queued/playing/done/failed/etc). Mirrors admin daily chart semantics.
  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)

  // Completed-only (done/completed). Mirrors viewer stats semantics.
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  // Best-effort unique user counts (all statuses / completed).
  uniqueUsersCountAll       Int @default(0)
  uniqueUsersCountCompleted Int @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@id([channelId, day])
  @@index([channelId, day])
  @@index([day])
}

// 30-day rolling window rollups (min-load strategy):
// keep expensive groupBy queries off the hot path by precomputing aggregates on a fixed window.
model ChannelUserStats30d {
  channelId String
  userId    String

  // Window boundaries (UTC). Informational; recomputed by job.
  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId])
  @@index([channelId])
  @@index([channelId, totalCoinsSpentSum])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model ChannelMemeStats30d {
  channelId String
  memeId    String

  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, memeId])
  @@index([channelId])
  @@index([channelId, completedActivationsCount])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model GlobalMemeStats30d {
  memeId String

  windowStart DateTime
  windowEnd   DateTime

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([memeId])
  @@index([completedActivationsCount])
  @@index([updatedAt])
}

// Daily rollups for viewer stats (day/week/month aggregation without scanning MemeActivation).
model ChannelMemeDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC
  memeId    String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, day, memeId])
  @@index([channelId, day])
  @@index([channelId, memeId])
  @@index([day])
}

model GlobalMemeDailyStats {
  day    DateTime // date_trunc('day', createdAt) in UTC
  memeId String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([day, memeId])
  @@index([day])
  @@index([memeId])
}
