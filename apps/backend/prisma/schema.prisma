generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id                            String   @id @default(uuid())
  // Legacy: Twitch channel id. Optional to support non-Twitch streamers in the future.
  twitchChannelId               String?  @unique
  slug                          String   @unique
  name                          String
  rewardIdForCoins              String?
  coinPerPointRatio             Float    @default(1.0)
  rewardEnabled                 Boolean  @default(false) // Is reward enabled/active
  rewardTitle                   String? // Title of the reward in Twitch
  rewardCost                    Int? // Cost in channel points
  rewardCoins                   Int? // Coins granted per redemption
  // If true, coins for the Twitch channel points reward are granted only when stream is online.
  rewardOnlyWhenLive            Boolean  @default(false)
  coinIconUrl                   String? // Custom coin icon URL from Twitch reward
  primaryColor                  String? // Hex color for primary theme
  secondaryColor                String? // Hex color for secondary theme
  accentColor                   String? // Hex color for accent
  defaultPriceCoins             Int?     @default(100) // Default price for memes in this channel
  // Legacy: Coins granted to submitter when their submission is approved (kept for back-compat).
  submissionRewardCoins         Int      @default(0)
  // New: Separate rewards (upload/url vs pool import).
  submissionRewardCoinsUpload   Int      @default(0)
  submissionRewardCoinsPool     Int      @default(100)
  // Legacy: If true, submission approval coins are granted only when stream is online.
  // NOTE: For pool-import rollout we decided to ALWAYS reward (ignore this flag).
  submissionRewardOnlyWhenLive  Boolean  @default(false)
  // Viewer submissions gate (global per-channel).
  // - submissionsEnabled=false => viewers cannot create new submissions.
  // - submissionsOnlyWhenLive=true => viewers can submit only while stream is online (best-effort per stream status store).
  submissionsEnabled            Boolean  @default(true)
  submissionsOnlyWhenLive       Boolean  @default(false)
  // Public control token for StreamDeck/StreamerBot-like integrations.
  // Stored as SHA-256 hex hash (never store raw token).
  submissionsControlTokenHash   String?  @unique
  // OBS overlay settings (server-side defaults for tokenized overlay URLs)
  overlayMode                   String   @default("queue") // queue | simultaneous
  overlayShowSender             Boolean  @default(false)
  overlayMaxConcurrent          Int      @default(3)
  // Advanced OBS overlay appearance/animation settings (stored as JSON string)
  overlayStyleJson              String?  @db.Text
  // OBS overlay presets (per-channel, stored as JSON string; validated/size-limited by API)
  overlayPresetsJson            String?  @db.Text
  // Increment to invalidate previously issued overlay tokens.
  overlayTokenVersion           Int      @default(1)
  // OBS credits overlay (titres) settings (stored as JSON string)
  creditsStyleJson              String?  @db.Text
  // Credits overlay: ignore chatters by name (case-insensitive). Stored as JSON array of strings.
  creditsIgnoredChattersJson    Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  // Increment to invalidate previously issued credits tokens.
  creditsTokenVersion           Int      @default(1)
  // Credits session reconnect window in minutes (keep session alive after stream goes offline / bot disconnects).
  creditsReconnectWindowMinutes Int      @default(60)
  // Chat bot "smart" command: stream duration settings (stored as JSON string; validated by API).
  streamDurationCommandJson     String?  @db.Text
  // Chat bot follow greeting settings
  followGreetingsEnabled        Boolean  @default(false)
  followGreetingTemplate        String?  @db.Text
  // Streamer dashboard layout (cross-device). Null => use frontend default order.
  // Stored as JSON array of card ids (strings). Normalized/validated by API.
  dashboardCardOrder            Json?    @db.JsonB
  createdAt                     DateTime @default(now())

  users                        User[]
  wallets                      Wallet[]
  memes                        Meme[]
  channelMemes                 ChannelMeme[]
  submissions                  MemeSubmission[]
  redemptions                  Redemption[]
  activations                  MemeActivation[]
  auditLogs                    AuditLog[]
  promotions                   Promotion[]
  dailyStats                   ChannelDailyStats[]
  userStats30d                 ChannelUserStats30d[]
  memeStats30d                 ChannelMemeStats30d[]
  memeDailyStats               ChannelMemeDailyStats[]
  chatBotSubscriptions         ChatBotSubscription[]
  chatBotOutboxMessages        ChatBotOutboxMessage[]
  chatBotCommands              ChatBotCommand[]
  chatBotEventDedups           ChatBotEventDedup[]
  vkVideoChatBotSubscriptions  VkVideoChatBotSubscription[]
  vkVideoChatBotOutboxMessages VkVideoChatBotOutboxMessage[]
  botIntegrations              BotIntegrationSettings[]
  youTubeChatBotSubscriptions  YouTubeChatBotSubscription[]
  youTubeChatBotOutboxMessages YouTubeChatBotOutboxMessage[]
  youTubeBotIntegration        YouTubeBotIntegration?
  vkVideoBotIntegration        VkVideoBotIntegration?
  twitchBotIntegration         TwitchBotIntegration?
  entitlements                 ChannelEntitlement[]
}

// Channel-scoped feature entitlements (subscription gates / feature flags).
// Additive + safe for shared DB between prod/beta.
// Example key: "custom_bot" (allows per-channel bot sender override).
model ChannelEntitlement {
  id        String    @id @default(uuid())
  channelId String
  key       String
  enabled   Boolean   @default(true)
  expiresAt DateTime?
  source    String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, key])
  @@index([channelId])
  @@index([key, enabled])
  @@index([expiresAt])
}

enum BotIntegrationProvider {
  twitch
  vkplaylive
  vkvideo
  youtube
}

// Per-channel bot integration toggles (survive restarts/deploys).
// - twitch: gates ChatBotSubscription (Twitch IRC bot joins/parts)
// - vkplaylive: reserved for VKPlay Live chat integration (uses ENV mapping for now)
model BotIntegrationSettings {
  id        String                 @id @default(uuid())
  channelId String
  provider  BotIntegrationProvider
  enabled   Boolean                @default(false)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, provider])
  @@index([channelId])
  @@index([provider, enabled])
  @@index([enabled])
}

enum ExternalAccountProvider {
  twitch
  youtube
  vk
  vkvideo
  vkplay
  kick
  trovo
  boosty
}

// VK Video Live chat bot subscriptions (global bot account joins many channels).
// Each MemAlerts Channel maps to a single VK Video Live channel identifier used by the chat connection.
model VkVideoChatBotSubscription {
  id                String   @id @default(uuid())
  channelId         String
  // Channel owner (used to access VKVideo API for roles; optional for backward compatibility).
  userId            String?
  vkvideoChannelId  String // platform channel identifier (exact format depends on VKVideo chat API)
  // Full channel URL on VK Video Live (required to resolve stream_id and websocket channel names via DevAPI).
  vkvideoChannelUrl String?
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([channelId])
  @@index([enabled])
  @@index([vkvideoChannelId])
  @@index([vkvideoChannelUrl])
  @@index([channelId])
  @@index([userId])
}

// VK Video Live chat bot outbox for sending messages via the separate vkvideo chatbot runner process.
model VkVideoChatBotOutboxMessage {
  id               String @id @default(uuid())
  channelId        String
  vkvideoChannelId String
  message          String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([vkvideoChannelId, status, createdAt])
  @@index([createdAt])
}

enum OAuthStateKind {
  login
  link
  bot_link
}

// Global Twitch IRC bot subscriptions (single bot account joins many channels).
model ChatBotSubscription {
  id          String   @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (for JOIN #login)
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([twitchLogin])
  @@index([channelId])
}

// YouTube chat bot subscriptions (per-channel, uses the streamer's linked YouTube account).
// Each MemAlerts Channel maps to a single YouTube channelId (owner's channel).
model YouTubeChatBotSubscription {
  id               String   @id @default(uuid())
  channelId        String
  userId           String
  youtubeChannelId String
  enabled          Boolean  @default(true)
  createdAt        DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([enabled])
  @@index([youtubeChannelId])
  @@index([userId])
  @@index([channelId])
}

// YouTube chat bot outbox for sending messages via the separate youtubeChatbotRunner process.
// API enqueues messages here; runner polls, delivers to YouTube Live Chat, then marks sent/failed.
model YouTubeChatBotOutboxMessage {
  id               String @id @default(uuid())
  channelId        String
  youtubeChannelId String
  message          String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([youtubeChannelId, status, createdAt])
  @@index([createdAt])
}

// Chat bot outbox for sending messages via the separate chatbotRunner process.
// API enqueues messages here; runner polls, delivers to Twitch IRC, then marks sent/failed.
model ChatBotOutboxMessage {
  id          String @id @default(uuid())
  channelId   String
  twitchLogin String // lowercase twitch channel login (target channel)
  message     String @db.Text

  status    String  @default("pending") // pending | processing | sent | failed
  attempts  Int     @default(0)
  lastError String? @db.Text

  processingAt DateTime?
  sentAt       DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([channelId, status, createdAt])
  @@index([twitchLogin, status, createdAt])
  @@index([createdAt])
}

// Per-channel chat bot commands (trigger -> response).
model ChatBotCommand {
  id                    String   @id @default(uuid())
  channelId             String
  trigger               String
  triggerNormalized     String
  response              String   @db.Text
  enabled               Boolean  @default(true)
  // If true, bot replies only when stream is online.
  onlyWhenLive          Boolean  @default(false)
  // Command audience:
  // - if both arrays are empty => everyone can trigger the command
  // - if allowedUsers contains sender login => allowed
  // - else if allowedRoles contains sender role => allowed
  // NOTE: "follower" role is currently not resolvable from IRC tags; see chatbotRunner.ts.
  allowedRoles          Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  allowedUsers          Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  // VKVideo-specific role ids (from VKVideo Channel Roles API).
  // Stored separately because Twitch allowedRoles are a fixed enum.
  vkvideoAllowedRoleIds Json     @default(dbgenerated("'[]'::jsonb")) @db.JsonB
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, triggerNormalized])
  @@index([channelId])
  @@index([enabled])
  @@index([channelId, enabled])
  @@index([triggerNormalized])
}

// Dedupe table for chat-bot-triggering events (e.g., EventSub follow) to prevent duplicate greetings.
model ChatBotEventDedup {
  id        String   @id @default(uuid())
  channelId String
  kind      String // e.g. "follow"
  eventId   String
  createdAt DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([kind, eventId])
  @@index([channelId])
  @@index([kind])
  @@index([createdAt])
}

// Per-user cross-device UI preferences.
// NOTE: kept additive and isolated to a single row per user (no channel dimension).
model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  theme                String   @default("light") // light | dark
  autoplayMemesEnabled Boolean  @default(true)
  memeModalMuted       Boolean  @default(false)
  coinsInfoSeen        Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id                 String   @id @default(uuid())
  // Legacy: Twitch user id. Optional to support non-Twitch identities in the future.
  twitchUserId       String?  @unique
  displayName        String
  profileImageUrl    String? // Twitch profile image URL
  role               String // viewer, streamer, admin
  channelId          String?
  twitchAccessToken  String? // Twitch OAuth access token for API calls
  twitchRefreshToken String? // Twitch OAuth refresh token
  hasBetaAccess      Boolean  @default(false) // Beta access flag
  createdAt          DateTime @default(now())

  channel                     Channel?                     @relation(fields: [channelId], references: [id], onDelete: SetNull)
  preference                  UserPreference?
  externalAccounts            ExternalAccount[]
  oauthStates                 OAuthState[]
  youTubeChatBotSubscriptions YouTubeChatBotSubscription[]
  vkVideoChatBotSubscriptions VkVideoChatBotSubscription[]
  wallets                     Wallet[]
  memesCreated                Meme[]                       @relation("CreatedBy")
  memesApproved               Meme[]                       @relation("ApprovedBy")
  memeAssetsCreated           MemeAsset[]                  @relation("MemeAssetCreatedBy")
  memeAssetsHidden            MemeAsset[]                  @relation("MemeAssetHiddenBy")
  memeAssetsPurged            MemeAsset[]                  @relation("MemeAssetPurgedBy")
  channelMemesAdded           ChannelMeme[]                @relation("ChannelMemeAddedBy")
  channelMemesApproved        ChannelMeme[]                @relation("ChannelMemeApprovedBy")
  submissions                 MemeSubmission[]
  redemptions                 Redemption[]
  activations                 MemeActivation[]
  channelStats30d             ChannelUserStats30d[]
  auditLogs                   AuditLog[]
  betaAccess                  BetaAccess?

  @@index([twitchUserId])
  @@index([channelId])
  @@index([hasBetaAccess])
}

model ExternalAccount {
  id                String                  @id @default(uuid())
  userId            String
  provider          ExternalAccountProvider
  providerAccountId String

  // Profile-ish fields (best-effort, provider-dependent)
  displayName String?
  login       String?
  avatarUrl   String?
  profileUrl  String?

  // OAuth tokens (optional; some providers may not return refresh tokens etc.)
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?
  scopes         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user                       User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  youTubeBotIntegration      YouTubeBotIntegration?
  globalYouTubeBotCredential GlobalYouTubeBotCredential?
  vkVideoBotIntegration      VkVideoBotIntegration?
  globalVkVideoBotCredential GlobalVkVideoBotCredential?
  twitchBotIntegration       TwitchBotIntegration?
  globalTwitchBotCredential  GlobalTwitchBotCredential?

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
  @@index([providerAccountId])
}

model OAuthState {
  // Random state string used as primary key (stored server-side for verification)
  state    String                  @id
  provider ExternalAccountProvider
  kind     OAuthStateKind

  // For link flows: the authenticated user that initiated linking.
  userId    String?
  // For bot_link flows: channelId of the streamer who initiated linking.
  channelId String?

  // Redirect handling
  redirectTo String?
  origin     String?

  // PKCE-ready (not used for Twitch currently, but stored for future providers)
  codeVerifier String?

  expiresAt  DateTime
  consumedAt DateTime?

  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([provider, kind])
  @@index([userId])
  @@index([channelId])
}

// Optional per-channel YouTube "bot account" override.
// If present, YouTube chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global YouTube bot token (YOUTUBE_BOT_REFRESH_TOKEN).
model YouTubeBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared YouTube bot credential (single "default MemAlerts bot" account).
// Linked by admin once; used as sender for YouTube chat messages when a channel has no override.
model GlobalYouTubeBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

// Optional per-channel VKVideo "bot account" override.
// If present, VKVideo chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global VKVideo bot credential.
model VkVideoBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared VKVideo bot credential (single default MemAlerts bot account).
// Linked by admin once; used as sender for VKVideo chat messages when a channel has no override.
model GlobalVkVideoBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

// Optional per-channel Twitch "bot account" override.
// If present, Twitch chat messages for the channel are sent using this ExternalAccount tokens.
// If absent, backend falls back to the global Twitch bot credential.
model TwitchBotIntegration {
  id                String   @id @default(uuid())
  channelId         String   @unique
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([channelId])
  @@index([externalAccountId])
}

// Global shared Twitch bot credential (single default MemAlerts bot account).
// Linked by admin once; used as sender for Twitch chat messages when a channel has no override.
model GlobalTwitchBotCredential {
  id                String   @id @default(uuid())
  externalAccountId String   @unique
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  externalAccount ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([enabled])
  @@index([externalAccountId])
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String
  channelId String
  balance   Int      @default(0)
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
}

model Meme {
  id               String    @id @default(uuid())
  channelId        String
  title            String
  type             String // image, gif, video, audio
  fileUrl          String
  fileHash         String? // SHA-256 hash for deduplication
  durationMs       Int
  priceCoins       Int
  status           String // pending, approved, rejected
  deletedAt        DateTime?
  createdByUserId  String?
  approvedByUserId String?
  createdAt        DateTime  @default(now())

  channel           Channel                 @relation(fields: [channelId], references: [id], onDelete: Cascade)
  createdBy         User?                   @relation("CreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  approvedBy        User?                   @relation("ApprovedBy", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  activations       MemeActivation[]
  globalStats30d    GlobalMemeStats30d?
  globalDailyStats  GlobalMemeDailyStats[]
  tags              MemeTag[]
  channelStats30d   ChannelMemeStats30d[]
  channelDailyStats ChannelMemeDailyStats[]
  fileHashRef       FileHash?               @relation(fields: [fileHash], references: [hash], onDelete: SetNull)

  @@index([channelId])
  @@index([status])
  @@index([deletedAt])
  @@index([createdByUserId])
  @@index([fileHash])
  // Common read pattern: list approved memes for a channel ordered by createdAt
  @@index([channelId, status, createdAt])
}

// Global meme object (shared pool). Appears in pool once at least one ChannelMeme is approved.
model MemeAsset {
  id         String  @id @default(uuid())
  type       String // image, gif, video, audio (currently video-only for submissions)
  fileUrl    String?
  fileHash   String? // SHA-256 hash for deduplication (preferred)
  durationMs Int

  createdByUserId String?
  createdAt       DateTime @default(now())

  // Pool moderation (does not affect already-added channel memes; only hides from pool listing)
  poolVisibility     String    @default("visible") // visible | hidden
  poolHiddenAt       DateTime?
  poolHiddenReason   String?
  poolHiddenByUserId String?

  // Safe deletion (quarantine)
  purgeRequestedAt DateTime?
  purgeNotBefore   DateTime?
  purgedAt         DateTime?
  purgeReason      String?
  purgeByUserId    String?

  createdBy   User?     @relation("MemeAssetCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  hiddenBy    User?     @relation("MemeAssetHiddenBy", fields: [poolHiddenByUserId], references: [id], onDelete: SetNull)
  purgedBy    User?     @relation("MemeAssetPurgedBy", fields: [purgeByUserId], references: [id], onDelete: SetNull)
  fileHashRef FileHash? @relation(fields: [fileHash], references: [hash], onDelete: SetNull)

  channelMemes ChannelMeme[]

  @@index([fileHash])
  @@index([createdByUserId])
  @@index([poolVisibility])
  @@index([poolHiddenAt])
  @@index([purgeNotBefore])
  @@index([purgedAt])
  @@index([createdAt])
}

// Channel-scoped adoption of a MemeAsset (what streamer actually uses).
model ChannelMeme {
  id           String  @id @default(uuid())
  channelId    String
  memeAssetId  String
  // Back-compat bridge during migration: points to legacy Meme.id (optional).
  legacyMemeId String?

  status    String    @default("approved") // pending | approved | rejected | disabled
  deletedAt DateTime?

  // Channel-specific fields
  title      String
  priceCoins Int

  addedByUserId    String?
  approvedByUserId String?
  approvedAt       DateTime?
  createdAt        DateTime  @default(now())

  channel   Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset @relation(fields: [memeAssetId], references: [id], onDelete: Cascade)

  addedBy    User? @relation("ChannelMemeAddedBy", fields: [addedByUserId], references: [id], onDelete: SetNull)
  approvedBy User? @relation("ChannelMemeApprovedBy", fields: [approvedByUserId], references: [id], onDelete: SetNull)

  // Activations that referenced this ChannelMeme at the time of activation.
  // (Opposite side of MemeActivation.channelMeme)
  activations MemeActivation[]

  @@unique([channelId, memeAssetId])
  @@index([channelId])
  @@index([memeAssetId])
  @@index([legacyMemeId])
  @@index([status])
  @@index([deletedAt])
  @@index([channelId, status, createdAt])
}

model MemeSubmission {
  id              String   @id @default(uuid())
  channelId       String
  submitterUserId String
  title           String
  type            String // image, gif, video, audio
  fileUrlTemp     String
  sourceUrl       String? // URL of imported meme from memalerts.com
  memeAssetId     String? // Pool import: references MemeAsset
  sourceKind      String   @default("upload") // upload | url | pool
  notes           String?
  status          String // pending, approved, rejected
  moderatorNotes  String?
  // Number of times the submitter resubmitted this submission after "needs_changes".
  // Used to enforce a small iteration limit for scale (prevents infinite loops).
  revision        Int      @default(0)
  createdAt       DateTime @default(now())

  channel   Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  submitter User                @relation(fields: [submitterUserId], references: [id], onDelete: Cascade)
  memeAsset MemeAsset?          @relation(fields: [memeAssetId], references: [id], onDelete: SetNull)
  tags      MemeSubmissionTag[]

  @@index([channelId])
  @@index([status])
  @@index([submitterUserId])
  @@index([memeAssetId])
  @@index([sourceKind])
}

model Redemption {
  id                 String   @id @default(uuid())
  channelId          String
  userId             String
  twitchRedemptionId String   @unique
  pointsSpent        Int
  coinsGranted       Int
  status             String // pending, completed, failed
  createdAt          DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([userId])
  @@index([twitchRedemptionId])
}

model MemeActivation {
  id            String   @id @default(uuid())
  channelId     String
  userId        String
  memeId        String
  channelMemeId String?
  coinsSpent    Int
  status        String // queued, playing, done, failed
  createdAt     DateTime @default(now())

  channel     Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  meme        Meme         @relation(fields: [memeId], references: [id], onDelete: Cascade)
  channelMeme ChannelMeme? @relation(fields: [channelMemeId], references: [id], onDelete: SetNull)

  @@index([channelId])
  @@index([userId])
  @@index([status])
  @@index([memeId])
  @@index([channelMemeId])
  // Common time-range scans (e.g., daily charts / rollups)
  @@index([channelId, createdAt])
  // Admin stats groupBy helpers (group by userId/memeId within a channel)
  @@index([channelId, userId])
  @@index([channelId, memeId])
  // Query helpers:
  // - popularity ranking: filter by channelId + status + createdAt, group by memeId
  @@index([channelId, status, createdAt, memeId])
  // - favorites ranking: filter by channelId + userId + status, group by memeId
  @@index([channelId, userId, status, memeId])
}

model AuditLog {
  id          String   @id @default(uuid())
  actorId     String?
  channelId   String
  action      String
  payloadJson String   @db.Text
  createdAt   DateTime @default(now())

  actor   User?   @relation(fields: [actorId], references: [id], onDelete: SetNull)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([actorId])
  @@index([createdAt])
}

model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  memes       MemeTag[]
  submissions MemeSubmissionTag[]

  @@index([name])
}

model MemeTag {
  id     String @id @default(uuid())
  memeId String
  tagId  String

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([memeId, tagId])
  @@index([memeId])
  @@index([tagId])
}

model MemeSubmissionTag {
  id           String @id @default(uuid())
  submissionId String
  tagId        String

  submission MemeSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  tag        Tag            @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([submissionId, tagId])
  @@index([submissionId])
  @@index([tagId])
}

model Promotion {
  id              String   @id @default(uuid())
  channelId       String
  name            String
  discountPercent Float // 0-100, e.g., 50 for 50% discount
  startDate       DateTime
  endDate         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([channelId])
  @@index([isActive])
  @@index([startDate, endDate])
}

model FileHash {
  hash           String   @id // SHA-256 hash
  filePath       String // Path to physical file
  referenceCount Int      @default(1) // Number of references to this file
  fileSize       BigInt // File size in bytes
  mimeType       String // MIME type of the file
  createdAt      DateTime @default(now())

  memes      Meme[]
  memeAssets MemeAsset[]

  @@index([referenceCount])
}

model BetaAccess {
  id          String    @id @default(uuid())
  userId      String    @unique
  status      String // pending, approved, rejected
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  approvedBy  String? // User ID who approved/rejected
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

// Rollup / pre-aggregations for performance at scale.
// These tables are additive and safe for shared DB (beta+prod) when deployed with expand/contract strategy.
model ChannelDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC

  // All statuses (queued/playing/done/failed/etc). Mirrors admin daily chart semantics.
  totalActivationsCount Int    @default(0)
  totalCoinsSpentSum    BigInt @default(0)

  // Completed-only (done/completed). Mirrors viewer stats semantics.
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  // Best-effort unique user counts (all statuses / completed).
  uniqueUsersCountAll       Int @default(0)
  uniqueUsersCountCompleted Int @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@id([channelId, day])
  @@index([channelId, day])
  @@index([day])
}

// 30-day rolling window rollups (min-load strategy):
// keep expensive groupBy queries off the hot path by precomputing aggregates on a fixed window.
model ChannelUserStats30d {
  channelId String
  userId    String

  // Window boundaries (UTC). Informational; recomputed by job.
  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId])
  @@index([channelId])
  @@index([channelId, totalCoinsSpentSum])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model ChannelMemeStats30d {
  channelId String
  memeId    String

  windowStart DateTime
  windowEnd   DateTime

  totalActivationsCount     Int    @default(0)
  totalCoinsSpentSum        BigInt @default(0)
  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, memeId])
  @@index([channelId])
  @@index([channelId, completedActivationsCount])
  @@index([channelId, totalActivationsCount])
  @@index([updatedAt])
}

model GlobalMemeStats30d {
  memeId String

  windowStart DateTime
  windowEnd   DateTime

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([memeId])
  @@index([completedActivationsCount])
  @@index([updatedAt])
}

// Daily rollups for viewer stats (day/week/month aggregation without scanning MemeActivation).
model ChannelMemeDailyStats {
  channelId String
  day       DateTime // date_trunc('day', createdAt) in UTC
  memeId    String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  meme    Meme    @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([channelId, day, memeId])
  @@index([channelId, day])
  @@index([channelId, memeId])
  @@index([day])
}

model GlobalMemeDailyStats {
  day    DateTime // date_trunc('day', createdAt) in UTC
  memeId String

  completedActivationsCount Int    @default(0)
  completedCoinsSpentSum    BigInt @default(0)

  updatedAt DateTime @updatedAt

  meme Meme @relation(fields: [memeId], references: [id], onDelete: Cascade)

  @@id([day, memeId])
  @@index([day])
  @@index([memeId])
}
